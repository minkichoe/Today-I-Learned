# Real MySQL 8.0 1권

## 버퍼 풀
### LRU 리스트
LRU 리스트는 엄밀히 보면 New 서브 리스트(상위 5/8 영역)이 MRU, Old 서브 리스트(이하 3/8 영역)이 LRU 캐시다

각 LRU, MRU 리스트는 Head와 Tail이 있다 (링크드 리스트)

LRU와 MRU가 만나는 지점이 mid point이고, 새로운 데이터를 읽었을 때 버퍼풀에 추가하려면 이 지점(LRU 리스트의 Head)에 추가한다. (=mid point insertion)

**InnoDB 스토리지 엔진에서 데이터를 찾는 과정**
1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
   1. 어댑티브 해시 인덱스를 이용해 페이지 검색
   2. 해당 테이블의 인덱스(B-tree)를 이용해 페이지 검색
   3. 버퍼 풀에 이미 데이터 페이지가 있었다면 해당 페이지의 포인터를 MRU 방향으로 승급
2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
3. 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동
   4. Read Ahead와 같이 대량 읽기의 경우 디스크의 데이터 페이지가 버퍼 풀로 적재는 되지만 실제 쿼리에서 사용되지는 않을 수도 있으며, 이런 경우에는 MRU로 이동되지 않음. (참고로 Read Ahead는 where절 없는 select 문 같은 것들..)
5. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이(Age)가 부여되며, 오래되면 버퍼 풀에서 제거된다. 버퍼 풀의 데이터 페이지가 쿼리에 의해 사용되면 나이가 초기화되어 다시 젊어진다.
6. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가한다

### 플러시 리스트
디스크로 동기화되지 않은 데이터 페이지(= 더티 페이지)의 변경 시점 기준의 페이지 목록을 관리함

데이터가 변경되면 InnoDB는 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영한다.

### 프리 리스트
InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록이며, 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용됨

## 버퍼 풀과 리두 로그
버풔 풀과 리두 로그는 매우 밀접한 관계를 맺고 있다

버퍼 풀은 서버의 메모리가 허용하는 만큼 크게 설정하면 할수록 쿼리의 성능이 빨라진다.

버퍼 풀은 성능 향상을 위해 데이터 캐시와 쓰기 버퍼링이라는 두 가지 용도가 있는데, 메모리를 늘리는 것은 데이터 캐시를 향상시킨다

쓰기 버퍼링 기능을 향상시키려면 리두 로그와의 관계를 이해해야 한다

버퍼 풀은 클린 페이지와 더티 페이지를 갖고 있는데, 더티 페이지는 어느 순간에는 디스크로 기록돼야 한다

InnoDB 스토리지 엔진에서 리두 로그는 1개 이상의 고정 크기 파일을 연결해서 순환 고리처럼 사용한다

즉 데이터 변경이 계속 발생하면 리두 로그 파일에 기록됐던 로그 엔트리는 어느 순간 다시 새로운 로그 엔트리로 덮어 쓰인다

그래서 InnoDB 는 전체 리두 로그 파일에서 재사용 가능한 공간과 당장 재사용 불가능한 공간을 구분해서 관리해야 하는데, 불가능한 공간을 활성 리두 로그라고 한다

리두 로그 파일은 매번 기록될 때 로그 포지션은 계속 증가된 값을 갖게 되는데, 이를 LSN(Log Sequence Number)라고 한다

InnoDB가 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화하는데, 이렇게 발생한 체크포인트 중 가장 최근 체크포인트 지점의 LSN이 활성 리두 로그 공간의 시작점이 된다

하지만 활성 리두 로그 공간의 마지막은 계속해서 증가하기 때문에 체크포인트와 무관하다

가장 최근 체크포인트의 LSN과 마지막 리두 로그 엔트리의 LSN의 차이를 체크포인트 에이지라고 한다. 즉 활성 리두 로그 공간의 크기를 일컫는다.

InnoDB 버퍼 풀의 더티 페이지는 특정 리두 로그 엔트리와 관계를 가지고, 체크포인트가 발생하면 체크포인트 LSN보다 작은 리두 로그 엔트리와 관련된 더티 페이지는 모두 디스크로 동기화돼야 한다.

그럼 리두 로그 파일의 전체 크기를 버퍼 풀만큼 크게 유지시키는게 좋을까? -> 그렇지 않다.

리두 로그 파일의 전체 크기가 클경우 급작스러운 디스크 쓰기가 발생할 가능성이 높다.

버퍼 풀에 더티 페이지 비율이 너무 높은 상태에서 갑자기 버퍼 풀이 필요해지는 상황이 오면 InnoDB는 매우 많은 더티 페이지를 한 번에 기록해야 하는 상황이 온다

버퍼 풀의 크기가 100GB 이하의 MySQL 서버에서는 리두 로그 파일의 전체 크기를 대략 5~10GB로 설정하고 조금씩 늘려나가며 최적화하자
