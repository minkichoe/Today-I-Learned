# Real MySQL 8.0 1권

## 버퍼 풀 플러시
MySQL 8.0 부터는 더티 페이지 플러시에서 디스크 쓰기가 폭증 현상이 발생하지 않았다

InnoDB 스토리지 엔진은 성능상의 악영향 없이 플러시하기 위해 2개의 펄리시 기능을 백그라운드로 실행한다

= 플러시 리스트 플러시, LRU 리스트 플러시

### 플러시 리스트 플러시
플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 수행한다

한번에 얼마나 많이 디스크에 쓰는지에 따라 사용자의 쿼리 처리에 영향을 미친다

이를 위해 다음과 같은 시스템 변수들을 제공한다

- innodb_page_cleaners
  - 더티 페이지를 디스크로 동기화하는 스레드를 클리너 스레드라고 하는데, innodb_page_cleaners 시스템 변수는 클리너 스레드의 개수를 조정한다
- innodb_max_dirty_pages_pct_lwm
  - 더티 페이지를 백그라운드 동기화하는 최소 수치
- innodb_max_dirty_pages_pct
  - 더티 페이지의 비율
- innodb_io_capacity
  - 데이터베이스 서버에서 어느 정도의 디스크 읽고 쓰기가 가능한지 설정
- innodb_io_capacity_max
  - 데이터베이스 서버에서 어느 정도의 디스크 읽고 쓰기가 최대 가능한지 설정
- innodb_flush_neighbors
  - 하드 디스크의 이점을 살려 이웃 페이지들을 함께 처리하는 옵션. 요새는 SSD라 잘 안쓰인다
- innodb_adaptive_flushing
  - innodb_io_capacity 대신 리두 로그 증가 속도를 분석해서 플러시 하도록 설정
- innodb_adaptive_flushing_lwm
  - innodb_adaptive_flushing 을 실행하는 최소 비율

### LRU 리스트 플러시
LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 페이지들을 읽어올 공간을 만들어야 하는데, 이를 위해 LRU 리스트 플러시 함수가 사용된다

LRU 리스트의 끝부분부터 `innodb_lru_scan_depth` 만큼 페이지를 스캔해서 더티 페이지를 디스크에 동기화하고 클린 페이지는 프리 리스트로 페이지를 옮긴다

버퍼 풀 인스턴스별로 스캔하기 때문에 `innodb_buffer_pool_instances` * `innodb_lur_scan_depth` 수만큼 수행한다

## 버퍼 풀 상태 백업 및 복구

`innodb_buffer_pool_dump_now` 변수를 사용해서 백업하고 복구할 수 있다

버퍼 풀에 디스크 데이터들이 적재되어있지 않으면 예전에는 서비스 오픈을 위해 웜업을 했었는데, 그러지 않아도 된다

버퍼 풀이 100GB 일 때 백업도 100GB 인 것은 아니다. 메타 데이터들을 저장하기 때문에 작은 크기이고, 복구하면서 백업된 버퍼 풀과 디스크의 데이터의 상태가 다를 경우 무시된다

### 버퍼 풀의 적재 내용 확인

`information_schema` 데이터베이스에 `innodb_cached_indexes` 테이블 참고

## Double Write Buffer
더티 페이지 플러시할 때 일부만 기록되는 문제가 발생하면 그 페이지의 내용은 복구할 수 없을 수도 있다. 이렇게 페이지가 일부만 기록되는 현상을 파셜 페이지, 또는 톤 페이지라고 하는데 하드웨어의 오작동이나 시스템의 비정상 종료 등으로 발생할 수 있다.

InnoDB 스토리지 엔진에서는 이같은 문제를 막기 위해 Double Write 기법을 이용한다.

시스템 테이블스페이스의 DoubleWrite 버퍼에 더티 페이지들을 기록하고, 각 더티 페이지를 파일의 적당한 위치에 하나씩 랜덤으로 쓰기를 실행한다

실제 데이터 파일에 동기화되면 더이상 필요 없어지기 때문에 Double Write 버퍼의 내용은 실제 데이터 파일의 쓰기가 중간에 실패할 때만 원래의 목적으로 사용된다.

이 기능을 사용할지 여부는 `innodb_doublewrite`로 제어할 수 있다

SSD에서는 부담스러운 옵션이지만 데이터의 무결성이 매우 중요한 서비스에서는 활성화를 고려해볼 수 있다.

## 언두 로그

InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 이전 버전의 데이터를 별도로 백업한다. 이것을 언두 로그라고 한다.

**트랜잭션 보장**
- 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야 하는데, 이 때 언두 로그에 백업해둔 이전 버전의 데이터를 이용해 복구한다.

**격리 수준 보장**
- 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽어서 반환하기도 한다.

### 언두 로그 레코드 모니터링

언두 영역은 CUD로 인한 변경시 이전 데이터를 보관하는 곳이다.

트랜잭트랜잭션이 길어지면 언두 로그의 양은 급격하게 증가할 수 있으며, 트랜잭션이 완료되었다고 해서 해당 트랜잭션이 생성한 언두 로그를 즉시 삭제할 수 있는 것은 아니다.

격리 수준에 따라 다른 트랜잭션에서 해당 언두 로그를 읽어야할 수 있기 때문이다.

언두 로그 레코드가 얼마나 되는지 모니터링은 `SHOW ENGINE INNODB STATUS \G` 로 가능하다.

### 언두 테이블스페이스 관리

언두 로그가 저장되는 공간을 언두 테이블스페이스라고 한다. 버전별로 많은 변화가 있었다.

8.0부터는 `innodb_undo_tablespaces` 시스템 변수는 Deprecated 되었으며 언두 로그는 항상 시스템 테이블스페이스 외부의 별도 로그 파일에 기록된다.

