# Real MySQL 8.0 1권 (~ 110p) 정리

## 쿼리를 실행했을 때 대략적인 흐름

1. 프로그래밍 언어와 드라이버에 의한 API 호출
2. MySQL 엔진
   1. 쿼리 파서
   2. 옵티마이저
   3. 실행기
3. MySQL 스토리지 엔진
   - InnoDB \*
   - MyISAM
   - Memory
   - CSV
   - ...
4. 물리 데이터 영역

## 데이터 딕셔너리 구성을 InnoDB로 변경
데이터 딕셔너리: MySQL 서버가 데이터베이스 객체에 대한 정보를 저장하는 데이터베이스

5.7까지 FRM 파일로 관리되던 방식이라서 시스템이 비정상 중단되는 경우 데이터 딕셔너리가 손상될 수 있었음

하지만 8.0부터 ACID를 지원하는 InnoDB로 데이터 딕셔너리를 관리하게 되면서 데이터 딕셔너리의 내구성이 향상되었음

## InnoDB의 자동화된 장애 복구 

매우 견고해서 거의 발생하지 않지만, 디스크나 서버 하드웨어 이슈로 InnoDB 스토리지 엔진이 자동으로 복구하지 못하는 경우가 발생할 수 있음

MySQL은 시작시 InnoDB 데이터 파일(ibd)을 항상 자동 복구를 수행하는데, 이 때 불가능한 경우 MySQL 서버가 종료됨

이때는 `innodb_fordce_recovery` 시스템 변수를 1에서 6까지 조정하며 선별적으로 복구를 시도할 수 있음

하지만 위 옵션으로도 복구가 불가능한 경우 binary log 를 통해 복구하는 방법도 고려할 수 있다

## 스토리지 엔진과 플러그인 그리고 컴포넌트의 연관성

MySQL 스토리지 엔진은 플러그인으로 만들어진다

그래서 교체할 수 있고 데이터를 읽고 쓰는 역할(인터페이스)만 잘 구현한다면 사용자가 원하는대로 사용할 수 있다는 장점이 있다

하지만 플러그인도 단점이 있다
- 플러그인은 오직 MySQL 엔진과 인터페이스 할 수 있고 플러그인간 커뮤니케이션은 할 수 없다
- 플러그인은 MySQL 엔진의 변수나 함수를 직접 호출하기 때문에 안전하지 않다 (캡슐화 X)
- 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어렵다

이 단점을 해결하기 위해 컴포넌트가 생겼고, MySQL 8.0부터 비밀번호 검증 기능은 컴포넌트로 개선되었다

> 플러그인은 오직 MySQL 엔진과 인터페이스 할 수 있고 플러그인간 커뮤니케이션은 할 수 없다

실행 엔진이 실제적으로 오케스트레이션 하는 느낌이다

예를 들어 아래와 같은 쿼리를 실행했을 때 MySQL 엔진의 실행기와 핸들러(=스토리지 엔진)간의 상호작용만 보자면 아래와 같다
```sql
select * from product where category = '책상' group by sku;
```

1. 실행 엔진 -> 핸들러: 임시 테이블 만들라고 지시 (group by를 처리하는 방법으로 앞서 MySQL 엔진의 옵티마이저가 임시 테이블을 생성하기로 결정했다고 가정)
2. 실행 엔진 -> 핸들러: where 절에 일치하는 레코드 읽어오라고 핸들러에 지시
3. 실행 엔진 -> 핸들러: 읽어온 레코드 목록을 1번에서 생성했던 임시 테이블로 저장하라고 지시
4. 실행 엔진 -> 핸들러: 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 지시
5. 실행 엔진 -> 사용자 또는 다른 모듈: 쿼리 결과 전달

## InnoDB와 MyISAM 간의 차이
_(이 주제는 앞에서 가볍게 하고 다음 챕터에서 자세히 다룬다고 한다)_

### InnoDB
InnoDB는 클러스터 방식이다. 그래서 pk를 클러스터링 인덱스로 사용하며, 다른 인덱스들을 세컨더리 인덱스로 정의할 수 있다

클러스터링 인덱스는 데이터 노드의 물리 주소를 가리키지만, 세컨더리 인덱스는 데이터 노드의 물리 주소가 아닌 클러스터 인덱스를 가리킨다

그래서 클러스터링 인덱스는 range 성능이 세컨더리 인덱스에 비해 뛰어나다

실행 계획에서 pk와 다른 인덱스간에 경합시 pk가 우선되는 경우가 많은 이유이기도 하다 

별개로 외래키를 지원한다

### MyISAM
pk가 클러스터링 인덱스가 아니다

그래서 pk와 세컨더리 인덱스간 구조가 동일하며, pk는 유니크 제약을 가진 세컨더리 인덱스라고 보면 된다

pk와 인덱스들은 모두 물리적 주소 값(ROWID)를 가진다

## 스레딩 구조
여기서는 전통적인 MySQL의 스레딩 구조를 다루며, MySQL 엔터프라이즈에서 사용 가능한 스레드 풀은 뒤에서 다루도록 한다

아래 쿼리를 실행해보면 BACKGROUND, FOREGROUND 로 구분된 스레드들을 확인할 수 있다

```sql
select * from performance_schema.threads;
```

이 중에 `thread/sql/one_connection` 스레드는 실제 사용자의 요청을 처리하는 스레드이다

백그라운드 스레드는 MySQL 서버 설정에 따라 가변적이며 동일한 이름의 스레드가 있으면 병렬처리한다는 의미이다

### 포그라운드 스레드(= 클라이언트 스레드)

포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트 수만큼 존재하며 각자 요청된 쿼리를 처리한다

스레드 캐시(풀)이 있는데, `max_connections` 보다 커야 한다는 의미는 아니다

쿼리를 처리하고 스레드를 반납할 때 `thread_cache_size`보다 캐싱된 스레드 수가 적으면 캐시에 반납하고, 그렇지 않으면 스레드를 종료시킨다

포그라운드 스레드는 데이터를 버퍼나 캐시에서 가져오는데, 거기에 없으면 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다

MyISAM 은 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만, InnoDB는 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 그 다음 작엄은 백그라운드 스레드가 처리한다 *

> InnoDB는 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 그 다음 작엄은 백그라운드 스레드가 처리한다

이 말은 기억만 해뒀다가 InnoDB 버퍼 풀, InnoDB 언두 로그 버퍼를 소개할 아래 영역에서 다시 살펴보자

### 백그라운드 스레드
InnoDB 기준으로 설명한다

- 인서트 버퍼를 병합하느 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드 *
- 데이터를 버퍼로 읽어오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

`innodb_write_io_threads`, `innodb_read_io_threads`로 읽기/쓰기에 대한 스레드 개수를 설정할 수 있다
읽기는 보통 클라이언트 스레드에서 많이 처리하니까 괜찮지만 쓰기는 적절히 늘려줘야 한다

쓰기는 지연(버퍼링)을 하기도 하지만 읽기는 지연할 수 없다. 그래서 InnoDB는 쓰기 작업으로 데이터 변경하는 경우 데이터 파일로 완전히 저장될 때 까지 기다리지 않아도 되도록 한다

How? _InnoDB 버퍼 풀, InnoDB 언두 로그 버퍼 설명 참고_

## 메모리 구조
### 글로벌 메모리 영역
포그라운드 스레드와 백그라운드 스레드 모두 참조 가능하다

MySQL의 시스템 변수로 설정해 둔 만큼 운영체제로부터 메모리를 할당 요청하며, 운영체제마다 방식이 다를 수 있다 (e.g. 요청하는 만큼 전부 할당해준다, 예약해두고 조금씩 할당해준다..)

- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

### 로컬 메모리 영역 (= 세션 메모리 영역)
클라이언트 스레드가 쿼리를 처리하는 데 사용하는 독립적인 메모리 영역

- 네트워크 버퍼(커넥션 버퍼)
- 정렬(소트) 버퍼
- 조인 버퍼
- 바이너리 로그 캐시

## MVCC(Multi Version Concurrency Control)
InnoDB 기준으로 설명한다

레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 이 기능의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있음

insert 하고 update 하는 과정을 통해 버퍼 풀과 언두 로그, 데이터 파일에서의 라이프사이클을 확인해보자
```sql
create table member (
    id    bigint      not null primary key,
    name  varchar(20) not null,
    area  varchar(20) not null,
);

create index idx_area on member (area);

insert into member (name, area) values ('홍길동', '서울');

commit;
```

- 버퍼풀 상태: `1, '홍길동', '서울'`
- 언두 로그 상태: 비어있음
- 데이터 파일(디스크): `1, '홍길동', '서울'`

```sql
update member set area='경기' where id=1;
```

- 버퍼풀 상태: `1, '홍길동', '경기'`
- 언두 로그 상태: `1, '서울'`
- 데이터 파일(디스크): `1, '홍길동', ?`

**데이터 파일의 변경 내역이 ?인 이유**

> 클라이언트 스레드가 버퍼풀 상태와 언두 로그 상태를 변경하지만, 백그라운드 스레드가 이것을 물리 영역에 반영할 때 까지는 언제가 될지 알 수 없다 (앞서 버퍼링에 관한 내용) <br/>
> 하지만 InnoDB는 ACID를 보장하기 때문에, 일반적인 사용자가 버퍼 풀과 데이터 파일에 차이가 있을 거라는 우려를 하지 않아도 된다

아직 `commit;`이나 `rollback;`을 실행하지 않았다

이 때 아래 쿼리를 실행하면 격리 수준에 따라 결과가 다르다
```sql
select * from member where id = 1;
```

`READ_UNCOMMITED`: 클라이언트 스레드가 버퍼 풀을 읽어가서 업데이트 된 내용을 보게 됨

그 외 상위 격리 수준: 클라이언트 스레드가 버퍼 풀과 언두 영역을 확인하여 변경되기 전의 데이터를 반환

MVCC 에 대한 정리를 마쳐보자면, 하나의 레코드에 대해 2개의 버전이 유지되고 필요에 따라 어느 데이터가 보여지는지 상황에 따라 달라지는 구조이다

InnoDB 스토리지 엔진은 이 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행한다

특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않아도, 순수한 읽기 작업은 항상 잠금을 대기하지 않고 바로 실행된다

이를 '잠금 없는 일관된 읽기(Non-Locking Consistent Read)'라고 한다

서로 다른 트랜잭션이 하나의 레코드에 대해 계속 쓰기 작업을 하고(=Undo를 쌓으며) 교착상태에 발생하면 일반적으로 Undo 로그가 적은 트랜잭션을 롤백시킨다

**innodb_lock_wait_timeout**
> 💡 _프라이머리 키 기반의 조회 및 변경이 아주 높은 빈도로 실행되는 서비스가 구글에 있었는데, 매우 많은 트랜잭션을 동시에 실행해서 데드락 감지 스레드가 쿼리 실행들의 병목이 되어 성능을 저하시킨다는 것을 발견하여 리포트하고 비활성화 할 수 있게 되었다._

## 버퍼 풀
InnoDB 스토리지 엔진이 데이터를 읽을 때 해당 데이터 페이지를 읽어서 각 버퍼 풀 조각에 저장한다

MySQL 서버 설정 중 페이지 크기(`innodb_page_size`)의 조각으로 쪼개어 구성한다

버퍼 풀의 페이지 크기 조각을 관리하기 위해 크게 LRU 리스트, 플러시 리스트, 프리 리스트 구조를 관리한다

### LRU 리스트

[//]: # (**TODO: &#40;졸리다.. 여기부터 내일 고치기&#41;**)

[//]: # (LRU 리스트는 엄밀히 보면 New 서브 리스트&#40;상위 5/8 영역&#41;이 MRU, Old 서브 리스트&#40;이하 3/8 영역&#41;이 LRU 캐시다)

[//]: # ()
[//]: # (각 LRU, MRU 리스트는 Head와 Tail이 있다 &#40;링크드 리스트&#41;)

[//]: # ()
[//]: # (LRU와 MRU가 만나는 지점이 mid point이고, 새로운 데이터를 읽었을 때 버퍼풀에 추가하려면 이 지점&#40;LRU 리스트의 Head&#41;에 추가한다. &#40;=mid point insertion&#41;)

[//]: # ()
[//]: # (이 데이터가 실제로 읽히면 MRU의 Head 방향으로)
